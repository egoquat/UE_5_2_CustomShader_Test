
#pragma once

#define RT_PAYLOAD_TYPE_VFX 1

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "/Engine/Private/RayTracing/RayTracingHitGroupCommon.ush"
 
RWTexture2D<float4> outTex;
RaytracingAccelerationStructure TLAS;
uint2 ResTexture;

struct FCusotmRayPayload : FIntersectionPayload
{
    float3 TranslatedWorldPosition;
    float3 WorldNormal;
    void SetPosition(float3 position)
    {
        TranslatedWorldPosition = position;
    }
};

float3 RotateVectorYaw(float3 dir, float angle) {
    // Convert the angle from degrees to radians
    angle = radians(angle);

    // Calculate the sine and cosine of the angle
    float sinAngle = sin(angle);
    float cosAngle = cos(angle);

    // Create the rotation matrix around the Y-axis
    float3x3 rotationMatrix = float3x3(
        cosAngle, sinAngle, 0,
        -sinAngle, cosAngle, 0, 
        0, 0, 1
    );

    // Rotate the vector using the rotation matrix
    return mul(rotationMatrix, dir);
}

void ReconstructWorldPosition(uint2 PixelCoord, uint2 ResTex, float DeviceZ, out float3 OutTranslatedWorldPosition, out float3 OutCameraDirection)
{
    uint2 ResView = View.ViewSizeAndInvSize.xy;
    float2 coord = PixelCoord;
    coord.x = coord.x * ((float)ResView.x / (float)ResTex.x);
    coord.y = coord.y * ((float)ResView.y / (float)ResTex.y);
    float4 TranslatedWorldPosition = mul(float4(coord + 0.5, DeviceZ, 1), View.SVPositionToTranslatedWorld);
    TranslatedWorldPosition.xyz /= TranslatedWorldPosition.w;
    OutTranslatedWorldPosition = TranslatedWorldPosition.xyz;
    OutCameraDirection = normalize(TranslatedWorldPosition.xyz - View.TranslatedWorldCameraOrigin);
}

RAY_TRACING_ENTRY_RAYGEN(RayTraceTestRGS)
{
    uint2 PixelCoord = DispatchRaysIndex().xy + View.ViewRectMin.xy;
    float3 WorldPosition;
    float3 CameraDirection;
    ReconstructWorldPosition(PixelCoord, ResTexture, 0.1f, WorldPosition, CameraDirection);

    //float4 TranslatedWorldPosition = mul(float4(0.5f, 0.5f, 1, 1), View.SVPositionToTranslatedWorld);
    //TranslatedWorldPosition.xyz /= TranslatedWorldPosition.w;
    //WorldPosition = TranslatedWorldPosition.xyz;
    //WorldPosition = View.TranslatedWorldCameraOrigin;
    
    RayDesc Ray;
    Ray.Origin = WorldPosition;
    //Ray.Direction = RotateVectorYaw(CameraDirection, 90.0f);
    Ray.Direction = RotateVectorYaw(CameraDirection, 0.0f);
    //Ray.Direction = CameraDirection;
    Ray.TMin = 0.0f;
    Ray.TMax = 10000.0f;
 
    uint RayFlags = RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
    //uint RayFlags = 0;
    //uint RayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;
 
    //FIntersectionPayload Payload = (FIntersectionPayload) 0;
    FVFXTracePayload Payload = (FVFXTracePayload) 0;
    //FCusotmRayPayload Payload = (FCusotmRayPayload) 0;
	
    TraceRay(
        TLAS,   // AccelerationStructure
        RayFlags,
        RAY_TRACING_MASK_OPAQUE,
        RAY_TRACING_SHADER_SLOT_MATERIAL, // RayContributionToHitGroupIndex, defined by UE4
        RAY_TRACING_NUM_SHADER_SLOTS,     // MultiplierForGeometryContributionToShaderIndex, defined by UE4
        0,      // MissShaderIndex
        Ray,    // RayDesc
        Payload // Payload
    );
 
    if (Payload.IsHit() && Payload.HitT <= 10000.0f)
    {
        //outTex[PixelCoord] = float4(Payload.TranslatedWorldPosition,1);
        float rt = clamp(Payload.HitT/10000.0f, 0, 1);
        float ch = 1.0f/3.0f;
        float g=saturate(rt*3),b=saturate((rt-ch)*3),r=saturate((rt-(ch*2))*3);
        outTex[PixelCoord] = float4(r,g,b,1);
    }
    else
    {
        outTex[PixelCoord] = float4(0,0,0,1);
    }
}

RAY_TRACING_ENTRY_CLOSEST_HIT(RayTraceTestCHS, FVFXTracePayload, payload, BuiltInTriangleIntersectionAttributes, attribs)
{
    //float3 wPos = TranslatedWorldRayOrigin() + WorldRayDirection() * RayTCurrent();
    //payload.TranslatedWorldPosition = TranslatedWorldRayOrigin() + WorldRayDirection() * RayTCurrent();
    payload.HitT = RayTCurrent();
    //payload.HitT = RayTCurrent();
}

RAY_TRACING_ENTRY_MISS(RayTraceTestMS, FVFXTracePayload, payload)
{
    payload.SetMiss();
}